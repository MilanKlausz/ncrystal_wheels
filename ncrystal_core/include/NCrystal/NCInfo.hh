#ifndef NCrystal_Info_hh
#define NCrystal_Info_hh

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  This file is part of NCrystal (see https://mctools.github.io/ncrystal/)   //
//                                                                            //
//  Copyright 2015-2020 NCrystal developers                                   //
//                                                                            //
//  Licensed under the Apache License, Version 2.0 (the "License");           //
//  you may not use this file except in compliance with the License.          //
//  You may obtain a copy of the License at                                   //
//                                                                            //
//      http://www.apache.org/licenses/LICENSE-2.0                            //
//                                                                            //
//  Unless required by applicable law or agreed to in writing, software       //
//  distributed under the License is distributed on an "AS IS" BASIS,         //
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  //
//  See the License for the specific language governing permissions and       //
//  limitations under the License.                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "NCrystal/NCDefs.hh"
#include "NCrystal/NCSABData.hh"

/////////////////////////////////////////////////////////////////////////////////
// Data class containing information (high level or derived) about a given     //
// material. Instances of the class are typically generated by dedicated       //
// factories, based on interpretation of data files with e.g. crystallographic //
// information. Physics models in the form of for example NCScatter or         //
// NCAbsorption instances, are then initialised from these Info objects, thus  //
// providing a separation between data sources and algorithms working on the   //
// data.                                                                       //
/////////////////////////////////////////////////////////////////////////////////

namespace NCrystal {

  struct NCRYSTAL_API StructureInfo final {
    unsigned spacegroup;//From 1-230 if provided, 0 if information not available
    double lattice_a;//angstrom
    double lattice_b;//angstrom
    double lattice_c;//angstrom
    double alpha;//degree
    double beta;//degree
    double gamma;//degree
    double volume;//Aa^3
    unsigned n_atoms;//Number of atoms per unit cell
  };

  struct NCRYSTAL_API HKLInfo final {
    double dspacing;//angstrom
    double fsquared;//barn
    int h;
    int k;
    int l;
    unsigned multiplicity;

    //If the HKLInfo source knows the plane normals, they will be provided in
    //the following list as unit vectors. Only half of the normals should be
    //included in this list, since if n is a normal, so is -n. If demi_normals
    //is not empty, it will be true that multiplicity == 2*demi_normals.size().
    struct Normal {
      Normal(double a1, double a2, double a3) : x(a1), y(a2), z(a3) {}
      double x, y, z;
    };
    std::vector<Normal> demi_normals;//TODO for NC2: vector->pointer saves 16B

    //If eqv_hkl is not a null pointer, it contains the corresponding Miller
    //indices of the demi_normals as three 2-byte integers (short). Thus,
    //eqv_hkl has demi_normal.size()*3 entries:
    short * eqv_hkl;
    HKLInfo();
    ~HKLInfo();
    HKLInfo(const HKLInfo &o);
    HKLInfo& operator=(const HKLInfo &o);
    HKLInfo(const HKLInfo &&o);
    HKLInfo& operator=(HKLInfo &&o);
  };

  typedef std::vector<HKLInfo> HKLList;

  struct NCRYSTAL_API AtomInfo final {
    //TODO for NC2: More parameters capable of handling non-natural atoms
    AtomInfo() : atomic_number(0), number_per_unit_cell(0),debye_temp(0.),mean_square_displacement(0.) {}
    std::string element_name;
    unsigned atomic_number;
    unsigned number_per_unit_cell;
    //per-element debye temperature (0.0 if not available, see hasPerElementDebyeTemperature() below):
    double debye_temp;
    //Atomic coordinates (vector must be empty or have number_per_unit_cell
    //entries):
    struct Pos final { Pos(double a, double b, double c) : x(a),y(b),z(c) {}; double x, y, z; };
    std::vector<Pos> positions;
    //Mean-square-displacements in angstrom^2 (0.0 if not available). Note that
    //this is the displacement projected onto a linear axis, for direct usage in
    //isotropic Debye-Waller factors:
    double mean_square_displacement;
  };

  typedef std::vector<AtomInfo> AtomList;

  struct NCRYSTAL_API XSectProvider {
    //Provide non-Bragg scattering cross sections.
    //Accept lambda in angstrom and return x-sect in barn
    virtual double xsectScatNonBragg(const double& lambda) const = 0;
    virtual ~XSectProvider(){}
  };

  class NCRYSTAL_API DynamicInfo : public UniqueID {
  public:
    DynamicInfo(double fraction, const std::string& elementName, double temperature);
    virtual ~DynamicInfo() = 0;//Make abstract
    double fraction() const;
    const std::string& elementName() const;
    void changeFraction(double f) { m_fraction = f; }
    double temperature() const;//same as on associated Info object

  private:
    double m_fraction;
    std::string m_elementName;
    double m_temperature;
  };

  typedef std::vector<std::unique_ptr<const DynamicInfo>> DynamicInfoList;

  class NCRYSTAL_API DI_Sterile final : public DynamicInfo {
    //Class indicating elements for which inelastic neutron scattering is absent
    //or disabled.
  public:
    using DynamicInfo::DynamicInfo;
    virtual ~DI_Sterile();
  };

  class NCRYSTAL_API DI_FreeGas final : public DynamicInfo {
    //Class indicating elements for which inelastic neutron scattering should be
    //modelled as scattering on a free gas.
  public:
    using DynamicInfo::DynamicInfo;
    virtual ~DI_FreeGas();
  };

  class NCRYSTAL_API DI_ScatKnl : public DynamicInfo {
  public:
    //Base class for dynamic information which can, directly or indirectly,
    //result in a SABData scattering kernel. The class is mostly semantic, as no
    //SABData access interface is provided on this class, as some derived
    //classes (e.g. VDOS) need dedicated algorithms in order to create the
    //SABData object. This class does, however, provide a unified interface for
    //associated data which is needed in order to use the SABData for
    //scattering. Currently this is just the grid of energy points for which SAB
    //integration will perform analysis and caching.
    virtual ~DI_ScatKnl();

    //If source dictated what energy grid to use for caching cross-sections,
    //etc., it can be returned here. It is ok to return a null ptr, leaving the
    //decision entirely to the consuming code. Grids must have at least 3
    //entries, and grids of size 3 actually indicates [emin,emax,npts], where
    //any value can be 0 to leave the choice for the consuming code. Grids of
    //size >=4 most be proper grids.
    typedef std::shared_ptr<const VectD> EGridShPtr;
    virtual EGridShPtr energyGrid() const = 0;
  protected:
    using DynamicInfo::DynamicInfo;
  };

  class NCRYSTAL_API DI_ScatKnlDirect : public DI_ScatKnl {
  public:
    //Pre-calculated scattering kernel which at most needs a conversion to
    //SABData format before it is available. For reasons of efficiency, this
    //conversion is actually not required to be carried out before calling code
    //calls the MT-safe ensureBuildThenReturnSAB().
    using DI_ScatKnl::DI_ScatKnl;
    virtual ~DI_ScatKnlDirect();

    //Use ensureBuildThenReturnSAB to access the scattering kernel:
    std::shared_ptr<const SABData> ensureBuildThenReturnSAB() const;

    //check if SAB is already built:
    bool hasBuiltSAB() const;

  protected:
    //Implement in derived classes to build the completed SABData object (will
    //only be called once and in an MT-safe context, protected by per-object
    //mutex):
    virtual std::shared_ptr<const SABData> buildSAB() const = 0;
  private:
    mutable std::shared_ptr<const SABData> m_sabdata;
    mutable std::mutex m_mutex;
  };

  class NCRYSTAL_API DI_VDOS : public DI_ScatKnl {
  public:
    //For a solid material, a phonon spectrum in the form of a Vibrational
    //Density Of State (VDOS) parameterisation, can be expanded into a full
    //scattering kernel. The calling code is responsible for doing this,
    //including performing choices as to grid layout, expansion order, etc.
    using DI_ScatKnl::DI_ScatKnl;
    virtual ~DI_VDOS();
    virtual const VDOSData& vdosData() const = 0;

    //The above vdosData() function returns regularised VDOS. The following
    //functions provide optional access to the original curves (returns empty
    //vectors if not available):
    virtual const VectD& vdosOrigEgrid() const = 0;
    virtual const VectD& vdosOrigDensity() const = 0;
  };

  class NCRYSTAL_API DI_VDOSDebye final : public DI_ScatKnl {
  public:
    //An idealised VDOS spectrum, based on the Debye Model in which the spectrum
    //rises quadratically with phonon energy below a cutoff value, kT, where T
    //is the Debye temperature (which must be available on the associated Info
    //object).
    DI_VDOSDebye( double fraction,
                  const std::string& elementName,
                  double temperature,
                  double debyeTemperature );
    virtual ~DI_VDOSDebye();
    double debyeTemperature() const;
    EGridShPtr energyGrid() const override { return nullptr; }
  private:
    double m_dt;
  };

  class NCRYSTAL_API Info final : public RCBase {
  public:

    //////////////////////////
    // Check if crystalline //
    //////////////////////////

    //Materials can be crystalline (i.e. at least one of structure info, atomic
    //positions and hkl info) must be present. Non-crystalline materials must
    //always have dynamic info present.
    bool isCrystalline() const;

    /////////////////////////////////////////
    // Information about crystal structure //
    /////////////////////////////////////////

    bool hasStructureInfo() const;
    const StructureInfo& getStructureInfo() const;

    //Convenience method, calculating the d-spacing of a given Miller
    //index. Calling this incurs the overhead of creating a reciprocal lattice
    //matrix from the structure info:
    double dspacingFromHKL( int h, int k, int l ) const;

    /////////////////////////////////////////
    // Information about material dynamics //
    /////////////////////////////////////////

    bool hasDynamicInfo() const;
    const DynamicInfoList& getDynamicInfoList() const;

    /////////////////////////////////////////////
    // Information about cross-sections [barn] //
    /////////////////////////////////////////////

    //absorption cross-section (at 2200m/s):
    bool hasXSectAbsorption() const;
    double getXSectAbsorption() const;

    //saturated scattering cross-section (high E limit):
    bool hasXSectFree() const;
    double getXSectFree() const;

    /////////////////////////////////////////////////////////////////////////////////
    // Provides calculation of "background" (non-Bragg diffraction) cross-sections //
    /////////////////////////////////////////////////////////////////////////////////

    bool providesNonBraggXSects() const;
    double xsectScatNonBragg(double lambda) const;

    ///////////////////////////
    // Temperature [kelvin]  //
    ///////////////////////////

    bool hasTemperature() const;
    double getTemperature() const;

    /////////////////////////////////
    // Debye temperature [kelvin]  //
    /////////////////////////////////

    //Global Debye temperature:
    bool hasAnyDebyeTemperature() const;
    bool hasGlobalDebyeTemperature() const;
    double getGlobalDebyeTemperature() const;

    //Whether AtomInfo objects have per-element Debye temperatures available:
    bool hasPerElementDebyeTemperature() const;

    //Convenience function for accessing Debye temperatures from AtomInfo:
    double getDebyeTemperatureByElementName(const std::string&) const;

    //////////////////////
    // Atom Information //
    //////////////////////

    bool hasAtomInfo() const;
    AtomList::const_iterator atomInfoBegin() const;
    AtomList::const_iterator atomInfoEnd() const;

    //Whether AtomInfo objects have atomic coordinates available:
    bool hasAtomPositions() const;

    //Whether AtomInfo objects have mean-square-displacements available:
    bool hasAtomMSD() const;

    //See also hasPerElementDebyeTemperature() above.

    /////////////////////
    // HKL Information //
    /////////////////////

    bool hasHKLInfo() const;
    unsigned nHKL() const;
    HKLList::const_iterator hklBegin() const;//first (==end if empty)
    HKLList::const_iterator hklLast() const;//last (==end if empty)
    HKLList::const_iterator hklEnd() const;
    //The limits:
    double hklDLower() const;
    double hklDUpper() const;
    //The largest/smallest (both returns inf if nHKL=0):
    double hklDMinVal() const;
    double hklDMaxVal() const;

    //////////////////////////////
    // Expanded HKL Information //
    //////////////////////////////

    //Whether HKLInfo objects have demi_normals available:
    bool hasHKLDemiNormals() const;

    //Whether HKLInfo objects have eqv_hkl available:
    bool hasExpandedHKLInfo() const;

    //Search eqv_hkl lists for specific (h,k,l) value. Returns hklEnd() if not found:
    HKLList::const_iterator searchExpandedHKL(short h, short k, short l) const;

    /////////////////////
    // Density [g/cm^3] //
    /////////////////////

    bool hasDensity() const;
    double getDensity() const;

    /////////////////////////////////
    // Number density [atoms/Aa^3] //
    /////////////////////////////////

    bool hasNumberDensity() const;
    double getNumberDensity() const;

    ////////////////////////////////////////////////////////////////////
    // Basic composition (always consistent with AtomInfo if present) //
    ////////////////////////////////////////////////////////////////////

    bool hasComposition() const;
    const std::map<std::string,double>& getComposition() const;

    /////////////////////////////////////////////////////////////////////////////
    // Advanced interface, allowing clients to cache derived data directly on  //
    // the Info object. Keys should be rather verbose and start with unique    //
    // string for client (e.g. class name of client), to prevent clashes:      //
    /////////////////////////////////////////////////////////////////////////////

    class CacheEntry {};//base class for cached data.
    //The next two methods are MT-safe, protected by a mutex:
    CacheEntry* accessCache(std::string key);//null if not present.
    void setCache(std::string key, std::unique_ptr<CacheEntry>, bool allow_override=false);


    //////////////////////////////
    // Internals follow here... //
    //////////////////////////////

  public:
    //Methods used by factories when setting up an Info object:
    Info();
    void addAtom(const AtomInfo& ai) {ensureNoLock(); m_atomlist.push_back(ai); }
    void addAtom(AtomInfo&& ai) {ensureNoLock(); m_atomlist.push_back(std::move(ai)); }
    void enableHKLInfo(double dlower, double dupper);
    void addHKL(const HKLInfo& hi) { ensureNoLock(); m_hkllist.push_back(hi); }
    void setStructInfo(const StructureInfo& si) { ensureNoLock(); nc_assert_always(si.spacegroup!=999999); m_structinfo = si; }
    void setXSectFree(double x) { ensureNoLock(); m_xsect_free = x; }
    void setXSectAbsorption(double x) { ensureNoLock(); m_xsect_absorption = x; }
    void setTemperature(double t) { ensureNoLock(); m_temp = t; }
    void setGlobalDebyeTemperature(double dt) { ensureNoLock(); m_debyetemp = dt; }
    void setDensity(double d) { ensureNoLock(); m_density = d; }
    void setNumberDensity(double d) { ensureNoLock(); m_numberdensity = d; }
    void setXSectProvider(std::unique_ptr<XSectProvider> xsp) { ensureNoLock(); nc_assert(!!xsp); m_xsectprovider = std::move(xsp); }
    void addDynInfo(std::unique_ptr<DynamicInfo> di) { ensureNoLock(); nc_assert(di); m_dyninfolist.push_back(std::move(di)); }
    void setComposition(std::map<std::string,double>&& c) { m_composition = c; }

    void objectDone();//Finish up (sorts hkl list (by dspacing first), and atom info list (by Z first)). This locks the instance.
    bool isLocked() const { return m_lock; }

    UniqueIDValue getUniqueID() const { return m_uid.getUniqueID(); }

  private:
    void ensureNoLock();
    UniqueID m_uid;
    StructureInfo m_structinfo;
    AtomList m_atomlist;
    HKLList m_hkllist;//sorted by dspacing first
    DynamicInfoList m_dyninfolist;
    double m_hkl_dlower, m_hkl_dupper, m_density, m_numberdensity, m_xsect_free, m_xsect_absorption, m_temp, m_debyetemp;
    std::unique_ptr<XSectProvider> m_xsectprovider;
    std::map<std::string,double> m_composition;
    bool m_lock;

  protected:
    virtual ~Info();
  };
}


////////////////////////////
// Inline implementations //
////////////////////////////

namespace NCrystal {
  inline bool Info::isCrystalline() const { return hasStructureInfo() || hasAtomPositions() || hasHKLInfo(); }
  inline bool Info::hasStructureInfo() const { return m_structinfo.spacegroup!=999999; }
  inline const StructureInfo& Info::getStructureInfo() const  { nc_assert(hasStructureInfo()); return m_structinfo; }
  inline bool Info::hasXSectAbsorption() const { return m_xsect_absorption >= 0.0; }
  inline bool Info::hasXSectFree() const { return m_xsect_free >= 0.0; }
  inline double Info::getXSectAbsorption() const { nc_assert(hasXSectAbsorption()); return m_xsect_absorption; }
  inline double Info::getXSectFree() const { nc_assert(hasXSectFree()); return m_xsect_free; }
  inline bool Info::providesNonBraggXSects() const { return !!m_xsectprovider; }
  inline double Info::xsectScatNonBragg(double lambda) const  { return m_xsectprovider->xsectScatNonBragg(lambda); }
  inline bool Info::hasTemperature() const { return m_temp > 0.0; }
  inline bool Info::hasAnyDebyeTemperature() const { return hasGlobalDebyeTemperature() || hasPerElementDebyeTemperature(); }
  inline bool Info::hasGlobalDebyeTemperature() const { return m_debyetemp > 0.0; }
  inline double Info::getTemperature() const { nc_assert(hasTemperature()); return m_temp; }
  inline double Info::getGlobalDebyeTemperature() const { nc_assert(hasGlobalDebyeTemperature()); return m_debyetemp; }
  inline bool Info::hasPerElementDebyeTemperature() const { return hasAtomInfo() && m_atomlist.front().debye_temp > 0.0; }
  inline bool Info::hasAtomPositions() const { return hasAtomInfo() && !m_atomlist.front().positions.empty(); }
  inline bool Info::hasAtomMSD() const { return hasAtomInfo() && m_atomlist.front().mean_square_displacement>0.0; }
  inline bool Info::hasAtomInfo() const  { return !m_atomlist.empty(); }
  inline AtomList::const_iterator Info::atomInfoBegin() const { nc_assert(hasAtomInfo()); return m_atomlist.begin(); }
  inline AtomList::const_iterator Info::atomInfoEnd() const { nc_assert(hasAtomInfo()); return m_atomlist.end(); }
  inline bool Info::hasHKLInfo() const { return m_hkl_dupper>=m_hkl_dlower; }
  inline bool Info::hasExpandedHKLInfo() const { return hasHKLInfo() && !m_hkllist.empty() && m_hkllist.front().eqv_hkl; }
  inline bool Info::hasHKLDemiNormals() const { return hasHKLInfo() && !m_hkllist.empty() && ! m_hkllist.front().demi_normals.empty(); }
  inline unsigned Info::nHKL() const { nc_assert(hasHKLInfo()); return m_hkllist.size(); }
  inline HKLList::const_iterator Info::hklBegin() const { nc_assert(hasHKLInfo()); return m_hkllist.begin(); }
  inline HKLList::const_iterator Info::hklLast() const
  {
    nc_assert(hasHKLInfo());
    return m_hkllist.empty() ? m_hkllist.end() : std::prev(m_hkllist.end());
  }
  inline HKLList::const_iterator Info::hklEnd() const { nc_assert(hasHKLInfo()); return m_hkllist.end(); }
  inline double Info::hklDLower() const { nc_assert(hasHKLInfo()); return m_hkl_dlower; }
  inline double Info::hklDUpper() const { nc_assert(hasHKLInfo()); return m_hkl_dupper; }
  inline bool Info::hasDensity() const { return m_density > 0.0; }
  inline double Info::getDensity() const { nc_assert(hasDensity()); return m_density; }
  inline bool Info::hasNumberDensity() const { return m_numberdensity > 0.0; }
  inline double Info::getNumberDensity() const { nc_assert(hasNumberDensity()); return m_numberdensity; }
  inline HKLInfo::HKLInfo() : dspacing(0.), fsquared(0.), h(0), k(0), l(0),  multiplicity(0), eqv_hkl(0) {}
  inline HKLInfo::~HKLInfo() { delete[] eqv_hkl; }
  inline HKLInfo::HKLInfo(const HKLInfo &o) : eqv_hkl(0) { *this = o; }
  inline bool Info::hasDynamicInfo() const { return !m_dyninfolist.empty(); }
  inline const DynamicInfoList& Info::getDynamicInfoList() const  { return m_dyninfolist; }
  inline double DynamicInfo::fraction() const { return m_fraction; }
  inline double DynamicInfo::temperature() const { return m_temperature; }
  inline const std::string& DynamicInfo::elementName() const { return m_elementName; }
  inline bool Info::hasComposition() const { return !m_composition.empty(); }
  inline const std::map<std::string,double>& Info::getComposition() const { return m_composition; }
  inline DI_VDOSDebye::DI_VDOSDebye( double fr, const std::string& en, double tt,double dt )
    : DI_ScatKnl(fr,en,tt),m_dt(dt) { nc_assert(m_dt>0.0); }
  inline double DI_VDOSDebye::debyeTemperature() const { return m_dt; }
}

#endif
